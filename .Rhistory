),2)
mapping_matrix = cbind(rules_a1, rules_a2, rules_b1, rules_b2)
rownames(mapping_matrix) = c("1","0")
# vector that can be read as a function mapping the indexes of its entries to other indexes
# used to map all 48 coded columns to only 42 columns with 0 and 1
index_mapper = c(
1,2,3,4,5,5,6,7,8,9,10,10,11,12,13,14,14,15,15,16,17,18,19,20,21,22,23,24,25,26,26,27,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,42
)
# Transform all data by iterating over input data row-wise
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
# skip columns where multiple conditions must be met
if (j %in% c(5,6,12,16,17,18,19,30,31,40,41)){
next
}
# TODO: Seperate multiple comma seperated entries
# check whether entry evaluates to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j])) {
if (check_value(data[i,j],unlist(mapping_matrix["1",j]))) {
df[i,index_mapper[j]] = 1
}
# check whether entry evaluates to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j])) {
else if (check_value(data[i,j],unlist(mapping_matrix["0",j]))) {
df[i,index_mapper[j]] = 0
}
# keep original coded value if it cannot be mapped to 1 or 0
else {
df[i,index_mapper[j]] = data[i,j]
}
}
}
# Transform data were multiple conditions must be met
for (i in 1:nrow(data)) {
for (j in c(5, 16, 18, 30, 40)) {
# both conditions must be met to be evaluated to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j]) && data[i,j+1] %in% unlist(mapping_matrix["1",j+1])) {
if(check_value(data[i,j],unlist(mapping_matrix["1",j])) && check_value(data[i,j+1],unlist(mapping_matrix["1",j+1]))) {
df[i,index_mapper[j]] = 1
}
# only one condition must be violated to be evaluated to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j]) || data[i,j+1] %in% unlist(mapping_matrix["0",j+1])) {
else if(check_value(data[i,j],unlist(mapping_matrix["0",j])) || check_value(data[i,j+1],unlist(mapping_matrix["0",j+1]))) {
df[i,index_mapper[j]] = 0
}
# keep merged original coded value if it cannot be mapped to 1 or 0
else {
if (data[i,j] == "na" && data[i,j+1] =="na") {
df[i,index_mapper[j]] = "na"
} else {
df[i,index_mapper[j]] = paste(data[i,j],data[i,j+1])
}
}
}
}
View(df)
View(data)
debugSource("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R/transformation_0_1/transform_codes_to_0_1.R")
debug(transform_codes())
i
j
check_value(data[i,j],unlist(mapping_matrix["1",j]))
j
debug(transform_codes())
data[i,j]
data[i,j+1]
check_value(data[i,j],unlist(mapping_matrix["0",j]))
check_value = function(value, value_set, check_for_zero) {
# check if a coded value belongs to a certain value set
# if check_for_zero is true, it is enough that one value is in the set to return true
# value could contain a concatenated string of more than one code
# first, any existing spaces are removed
# next, a list with all codes is stored in values (could also be a list with just one element)
values = unlist(strsplit(str_replace_all(value, " ", ""), ","))
in_set = TRUE
for (code in values) {
if (check_for_zero && code %in% value_set) {
return(TRUE)
}
if (!(code %in% value_set)) {
in_set = FALSE
}
}
return(in_set)
}
transform_codes <- function(){
# TODO: add data as input later to function again
# TODO: remove later, just for debugging purposes
data <- read_csv2("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R/irr/input_data/marc_19_20.csv", show_col_types = FALSE)
data = data.frame(data, row.names = 1)
# This function transforms coded data to values of 0 and 1
# The applied transformation rules are specified in "Transformationsregeln Kodierung.docx"
# Input value: data of type dataframe (?)
# Create a result data frame with 42 columns and corresponding column titles
df <- data.frame(matrix(ncol = 42, nrow = nrow(data)))
custom_names <- c(
"a1_1_1",
"a1_1_2",
"a1_1_3",
"a1_2",
"a1_3",
"a1_4_1",
"a1_4_2",
"a1_4_3",
"a1_4_4",
"a1_5",
"a1_6",
"a2_1",
"a2_2",
"a2_3",
"a2_4",
"a2_5",
"a2_6_1",
"a2_6_2",
"a2_6_3",
"a2_6_4",
"a2_6_5",
"b1_1_1",
"b1_1_2",
"b1_1_2",
"b1_2",
"b1_3",
"b1_4_1",
"b1_4_2",
"b1_4_3",
"b1_4_4",
"b1_5",
"b1_6",
"b2_1",
"b2_2",
"b2_3",
"b2_4",
"b2_5",
"b2_6_1",
"b2_6_2",
"b2_6_3",
"b2_6_4",
"b2_6_5"
)
colnames(df) <- custom_names
# rules for mapping
# left column: values that are transformed to 1
# right column: values that are transformed to 0
# tasks in A1
rules_a1 = matrix(list(
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("k"), c("sp","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("d","f","u"),
c(""), c("1,2,3,4,5"), # todo: wie geh ich hier mit allen Fällen um? Muss ich das handeln?
c("k","kr","ks"), c("kt","ku","ab","f")
),2)
# tasks in A2
rules_a2 = matrix(list(
c("5"), c("0","1","2","3","4","6"),
c("k"), c("e","sp","p","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","kl","g","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f","int"),
c("k"), c("p","i","ab"),
c("k","d"), c("p", "f"),
c("5"), c("0","1","2","3","4","6","7","8","9","10","11","12"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
# tasks in B1
rules_b1 = matrix(list(
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("p","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("k","ks"), c("u","f"),
c("k","ks"), c("kt","ku","ab","f")
),2)
# tasks in B2
rules_b2 = matrix(list(
c("2"), c("0","1","3","4","5","6"),
c("k"), c("e","sp","l","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","kl","g","s","div","ab"),
c("k","ff","nb"), c("f","fk","n","int"),
c("k","fp"), c("sp","i","ab"),
c("5"), c("0","1","2","3","4","6","7","8","9"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
mapping_matrix = cbind(rules_a1, rules_a2, rules_b1, rules_b2)
rownames(mapping_matrix) = c("1","0")
# vector that can be read as a function mapping the indexes of its entries to other indexes
# used to map all 48 coded columns to only 42 columns with 0 and 1
index_mapper = c(
1,2,3,4,5,5,6,7,8,9,10,10,11,12,13,14,14,15,15,16,17,18,19,20,21,22,23,24,25,26,26,27,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,42
)
# Transform all data by iterating over input data row-wise
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
# skip columns where multiple conditions must be met
if (j %in% c(5,6,12,16,17,18,19,30,31,40,41)){
next
}
# TODO: Seperate multiple comma seperated entries
# check whether entry evaluates to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j])) {
if (check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# check whether entry evaluates to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j])) {
else if (check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep original coded value if it cannot be mapped to 1 or 0
else {
df[i,index_mapper[j]] = data[i,j]
}
}
}
# Transform data were multiple conditions must be met
# TODO: was wenn es nicht drin ist und nur eins von beidem nicht drin ist? dann wird check value false beim check ob es in 0 ist
for (i in 1:nrow(data)) {
for (j in c(5, 16, 18, 30, 40)) {
# both conditions must be met to be evaluated to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j]) && data[i,j+1] %in% unlist(mapping_matrix["1",j+1])) {
if(check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE) && check_value(data[i,j+1],unlist(mapping_matrix["1",j+1]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# only one condition must be violated to be evaluated to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j]) || data[i,j+1] %in% unlist(mapping_matrix["0",j+1])) {
else if(check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE) || check_value(data[i,j+1],unlist(mapping_matrix["0",j+1]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep merged original coded value if it cannot be mapped to 1 or 0
else {
if (data[i,j] == "na" && data[i,j+1] =="na") {
df[i,index_mapper[j]] = "na"
} else {
df[i,index_mapper[j]] = paste(data[i,j],data[i,j+1])
}
}
}
}
View(df)
x=3
# Install and load the igraph package if not already installed
if (!requireNamespace("igraph", quietly = TRUE)) {
install.packages("igraph")
}
library(igraph)
# Sample data
transition_data <- data.frame(
from_state = c("State1", "State2", "State3", "State1", "State2"),
to_state = c("State2", "State3", "State4", "State5", "State1"),
frequency = c(10, 5, 8, 12, 6)
)
# Create a directed graph
graph <- graph_from_data_frame(transition_data, directed = TRUE)
# Plot the graph with edge thickness proportional to frequency
plot(
graph,
edge.width = E(graph)$frequency,  # Use frequency as edge thickness
edge.arrow.size = 0.5,            # Set arrow size for directed edges
vertex.label = V(graph)$name,     # Display state names as labels
main = "Transition Graph with Edge Thickness based on Frequency"
)
# Install and load the igraph package if not already installed
if (!requireNamespace("igraph", quietly = TRUE)) {
install.packages("igraph")
}
library(igraph)
# Sample data
transition_data <- data.frame(
from_state = c("U", "I", "C", "C","E", "E"),
to_state = c("C", "C", "I", "E", "I", "C"),
frequency = c(1, 2, 1, 19, 6, 1, 7)
)
# Install and load the igraph package if not already installed
if (!requireNamespace("igraph", quietly = TRUE)) {
install.packages("igraph")
}
library(igraph)
# Sample data
transition_data <- data.frame(
from_state = c("U", "I", "C", "C","E", "E"),
to_state = c("C", "C", "I", "E", "I", "C"),
frequency = c(1, 2, 1, 9, 1, 7)
)
# Create a directed graph
graph <- graph_from_data_frame(transition_data, directed = TRUE)
# Plot the graph with edge thickness proportional to frequency
plot(
graph,
edge.width = E(graph)$frequency,  # Use frequency as edge thickness
edge.arrow.size = 0.5,            # Set arrow size for directed edges
vertex.label = V(graph)$name,     # Display state names as labels
main = "Transition Graph with Edge Thickness based on Frequency"
)
library(readr)
library(tidyverse)
library(stringr)
# Set working directory to folder where all R code related to the study is stored
setwd("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R")
# Load helper functions
source("helper_functions/pc_transform_codes_to_0_1_2.R")
source("helper_functions/pc_evaluate_mc_tasks.R")
source("helper_functions/handle_missing_values.R")
# Read coded data of all 20 classes
data_raw = data.frame(read_csv2("input_data/data_raw_final.csv", show_col_types = FALSE), row.names = 1)
data = transform_codes(data_raw)
row.names(data) = rownames(data_raw)
# TODO: Macht das Sinn oder wie geht man damit um? Für erste werden jetzt alle unklaren Einträge durch 0 ersetzt.
# Beispiel für unklar: k na bei b2_3: Es ist nicht korrekt (weil nicht beides korrekt ist) es ist auch nicht falsch (weil na nicht falsch ist) und es ist auch nicht na (Weil nicht beides na ist)
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
if (data[i,j] != "2" & data[i,j] != "1" & data[i,j] != "0" & !is.na(data[i,j])) {
print(c(colnames(data)[j], rownames(data)[i], data[i,j]))
data[i,j] = "0"
}
}
}
# Evaluate multiple choice tasks to one score
data_mc_raw = data # save data where mc items are not yet transformed into one score
data = evaluate_mc_tasks(data)
# # calculate statistics for partial credit tasks how often tasks were scored with 0, 1, 2
# statistic = data.frame(matrix(0,3,ncol(data)))
# rownames(statistic) = c("2","1","0")
# colnames(statistic) = colnames(data)
# for (i in 1:nrow(data)) {
#   for (j in 1:ncol(data)) {
#     if(is.na(data[i,j])) {
#       next
#     }
#     if(data[i,j] == "2") {
#       statistic["2",j] = statistic["2",j] + 1
#     } else if(data[i,j] == "1") {
#       statistic["1",j] = statistic["1",j] + 1
#     } else if(data[i,j] == "0") {
#       statistic["0",j] = statistic["0",j] + 1
#     }
#   }
# }
# code 2, 1 and 0 as numeric values (currently saved as characters)
# create a new dataframe so that datatypes are correct
data_clean = data.frame(matrix(0,nrow(data),ncol(data)),row.names = rownames(data))
colnames(data_clean) = colnames(data)
for (i in 1:nrow(data_clean)) {
for (j in 1:ncol(data_clean)) {
if (!is.na(data[i,j])) {
if (data[i,j] == "2") {
data_clean[i,j] = 2
} else if (data[i,j] == "1") {
data_clean[i,j] = 1
} else if (data[i,j] == "0") {
data_clean[i,j] = 0
} else {
# unknown code, handle as if wrong
data_clean[i,j] = 0
}
} else {
data_clean[i,j] = NA
}
}
}
# same for raw mc data
data_mc_raw_clean = data.frame(matrix(0,nrow(data_mc_raw),ncol(data_mc_raw)),row.names = rownames(data_mc_raw))
colnames(data_mc_raw_clean) = colnames(data_mc_raw)
for (i in 1:nrow(data_mc_raw_clean)) {
for (j in 1:ncol(data_mc_raw_clean)) {
if (!is.na(data_mc_raw[i,j])) {
if (data_mc_raw[i,j] == "2") {
data_mc_raw_clean[i,j] = 2
} else if (data_mc_raw[i,j] == "1") {
data_mc_raw_clean[i,j] = 1
} else if (data_mc_raw[i,j] == "0") {
data_mc_raw_clean[i,j] = 0
} else {
data_mc_raw_clean[i,j] = NA
}
}
}
}
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
View(data_clean)
data_3
View(data_2)
setwd("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R")
# Load helper functions
source("helper_functions/pc_transform_codes_to_0_1_2.R")
source("helper_functions/pc_evaluate_mc_tasks.R")
source("helper_functions/handle_missing_values.R")
# Read coded data of all 20 classes
data_raw = data.frame(read_csv2("input_data/data_raw_final.csv", show_col_types = FALSE), row.names = 1)
data = transform_codes(data_raw)
row.names(data) = rownames(data_raw)
# TODO: Macht das Sinn oder wie geht man damit um? Für erste werden jetzt alle unklaren Einträge durch 0 ersetzt.
# Beispiel für unklar: k na bei b2_3: Es ist nicht korrekt (weil nicht beides korrekt ist) es ist auch nicht falsch (weil na nicht falsch ist) und es ist auch nicht na (Weil nicht beides na ist)
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
if (data[i,j] != "2" & data[i,j] != "1" & data[i,j] != "0" & !is.na(data[i,j])) {
print(c(colnames(data)[j], rownames(data)[i], data[i,j]))
data[i,j] = "0"
}
}
}
# Evaluate multiple choice tasks to one score
data_mc_raw = data # save data where mc items are not yet transformed into one score
data = pc_evaluate_mc_tasks(data)
source("helper_functions/pc_evaluate_mc_tasks.R")
data = pc_evaluate_mc_tasks(data)
warnings()
is.na(NA)
is.na("1")
source("helper_functions/pc_evaluate_mc_tasks.R")
data = pc_evaluate_mc_tasks(data)
source("helper_functions/pc_evaluate_mc_tasks.R")
data = pc_evaluate_mc_tasks(data)
source("helper_functions/pc_evaluate_mc_tasks.R")
data = pc_evaluate_mc_tasks(data)
data
colnames(data)[1]
View(data)
source("helper_functions/pc_evaluate_mc_tasks.R")
data = pc_evaluate_mc_tasks(data)
View(data)
# code 2, 1 and 0 as numeric values (currently saved as characters)
# create a new dataframe so that datatypes are correct
data_clean = data.frame(matrix(0,nrow(data),ncol(data)),row.names = rownames(data))
colnames(data_clean) = colnames(data)
for (i in 1:nrow(data_clean)) {
for (j in 1:ncol(data_clean)) {
if (!is.na(data[i,j])) {
if (data[i,j] == "2") {
data_clean[i,j] = 2
} else if (data[i,j] == "1") {
data_clean[i,j] = 1
} else if (data[i,j] == "0") {
data_clean[i,j] = 0
} else {
# unknown code, handle as if wrong
data_clean[i,j] = 0
}
} else {
data_clean[i,j] = NA
}
}
}
# same for raw mc data
data_mc_raw_clean = data.frame(matrix(0,nrow(data_mc_raw),ncol(data_mc_raw)),row.names = rownames(data_mc_raw))
colnames(data_mc_raw_clean) = colnames(data_mc_raw)
for (i in 1:nrow(data_mc_raw_clean)) {
for (j in 1:ncol(data_mc_raw_clean)) {
if (!is.na(data_mc_raw[i,j])) {
if (data_mc_raw[i,j] == "2") {
data_mc_raw_clean[i,j] = 2
} else if (data_mc_raw[i,j] == "1") {
data_mc_raw_clean[i,j] = 1
} else if (data_mc_raw[i,j] == "0") {
data_mc_raw_clean[i,j] = 0
} else {
data_mc_raw_clean[i,j] = NA
}
}
}
}
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
View(data_clean)
source("helper_functions/handle_missing_values.R")
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
data[329,6]
a2_start
last_done_pre
source("helper_functions/handle_missing_values.R")
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
source("helper_functions/handle_missing_values.R")
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
source("helper_functions/handle_missing_values.R")
# TODO: hier müsste eigentlich zwischen omitted und not reached unterschieden werden+
# TODO: WIrd hier gemacht, muss noch getestet werden
# Handling of missing data
data_2 = handle_missing_values(data_clean, FALSE)
View(data_2)
