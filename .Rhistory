return(in_set)
}
# TODO: add data as input later to function again
# TODO: remove later, just for debugging purposes
data <- read_csv2("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R/irr/input_data/marc_19_20.csv", show_col_types = FALSE)
library(stringr)
library(readr)
# TODO: add data as input later to function again
# TODO: remove later, just for debugging purposes
data <- read_csv2("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R/irr/input_data/marc_19_20.csv", show_col_types = FALSE)
data = data.frame(data, row.names = 1)
# Create a result data frame with 42 columns and corresponding column titles
df <- data.frame(matrix(ncol = 42, nrow = nrow(data)))
custom_names <- c(
"a1_1_1",
"a1_1_2",
"a1_1_3",
"a1_2",
"a1_3",
"a1_4_1",
"a1_4_2",
"a1_4_3",
"a1_4_4",
"a1_5",
"a1_6",
"a2_1",
"a2_2",
"a2_3",
"a2_4",
"a2_5",
"a2_6_1",
"a2_6_2",
"a2_6_3",
"a2_6_4",
"a2_6_5",
"b1_1_1",
"b1_1_2",
"b1_1_2",
"b1_2",
"b1_3",
"b1_4_1",
"b1_4_2",
"b1_4_3",
"b1_4_4",
"b1_5",
"b1_6",
"b2_1",
"b2_2",
"b2_3",
"b2_4",
"b2_5",
"b2_6_1",
"b2_6_2",
"b2_6_3",
"b2_6_4",
"b2_6_5"
)
colnames(df) <- custom_names
# rules for mapping
# left column: values that are transformed to 1
# right column: values that are transformed to 0
# tasks in A1
rules_a1 = matrix(list(
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("k"), c("sp","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("d","f","u"),
c(""), c("1,2,3,4,5"), # todo: wie geh ich hier mit allen Fällen um? Muss ich das handeln?
c("k","kr","ks"), c("kt","ku","ab","f")
),2)
# tasks in A2
rules_a2 = matrix(list(
c("5"), c("0","1","2","3","4","6"),
c("k"), c("e","sp","p","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","kl","g","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f","int"),
c("k"), c("p","i","ab"),
c("k","d"), c("p", "f"),
c("5"), c("0","1","2","3","4","6","7","8","9","10","11","12"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
# tasks in B1
rules_b1 = matrix(list(
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("p","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("k","ks"), c("u","f"),
c("k","ks"), c("kt","ku","ab","f")
),2)
# tasks in B2
rules_b2 = matrix(list(
c("2"), c("0","1","3","4","5","6"),
c("k"), c("e","sp","l","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","kl","g","s","div","ab"),
c("k","ff","nb"), c("f","fk","n","int"),
c("k","fp"), c("sp","i","ab"),
c("5"), c("0","1","2","3","4","6","7","8","9"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
mapping_matrix = cbind(rules_a1, rules_a2, rules_b1, rules_b2)
rownames(mapping_matrix) = c("1","0")
# vector that can be read as a function mapping the indexes of its entries to other indexes
# used to map all 48 coded columns to only 42 columns with 0 and 1
index_mapper = c(
1,2,3,4,5,5,6,7,8,9,10,10,11,12,13,14,14,15,15,16,17,18,19,20,21,22,23,24,25,26,26,27,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,42
)
# Transform all data by iterating over input data row-wise
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
# skip columns where multiple conditions must be met
if (j %in% c(5,6,12,16,17,18,19,30,31,40,41)){
next
}
# TODO: Seperate multiple comma seperated entries
# check whether entry evaluates to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j])) {
if (check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# check whether entry evaluates to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j])) {
else if (check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep original coded value if it cannot be mapped to 1 or 0
else {
df[i,index_mapper[j]] = data[i,j]
}
}
}
# Transform data were multiple conditions must be met
# TODO: was wenn es nicht drin ist und nur eins von beidem nicht drin ist? dann wird check value false beim check ob es in 0 ist
for (i in 1:nrow(data)) {
for (j in c(5, 16, 18, 30, 40)) {
# both conditions must be met to be evaluated to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j]) && data[i,j+1] %in% unlist(mapping_matrix["1",j+1])) {
if(check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE) && check_value(data[i,j+1],unlist(mapping_matrix["1",j+1]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# only one condition must be violated to be evaluated to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j]) || data[i,j+1] %in% unlist(mapping_matrix["0",j+1])) {
else if(check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE) || check_value(data[i,j+1],unlist(mapping_matrix["0",j+1]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep merged original coded value if it cannot be mapped to 1 or 0
else {
if (data[i,j] == "na" && data[i,j+1] =="na") {
df[i,index_mapper[j]] = "na"
} else {
df[i,index_mapper[j]] = paste(data[i,j],data[i,j+1])
}
}
}
}
View(df)
rules_a1 = matrix(list(
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("k"), c("sp","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","5","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("d","f","u"),
c(""), c("1,2,3,4,5"), # todo: wie geh ich hier mit allen Fällen um? Muss ich das handeln?
c("k","kr","ks"), c("kt","ku","ab","f")
),2)
# tasks in A2
rules_a2 = matrix(list(
c("5"), c("0","1","2","3","4","6"),
c("k"), c("e","sp","p","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","5","kl","g","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f","int"),
c("k"), c("p","i","ab"),
c("k","d"), c("p", "f"),
c("5"), c("0","1","2","3","4","6","7","8","9","10","11","12"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
# tasks in B1
rules_b1 = matrix(list(
c("2"), c("1","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("k"), c("p","i","g","nl","str","s","ab"),
c("k","1","2","sp"), c("3","4","5","kl","g","x","y","s","div","ab"),
c("k","fk","ff","ub","d","n"), c("f"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("k","ks"), c("u","f"),
c("k","ks"), c("kt","ku","ab","f")
),2)
# tasks in B2
rules_b2 = matrix(list(
c("2"), c("0","1","3","4","5","6"),
c("k"), c("e","sp","l","g","nl","str","s","ab"),
c("k","1","2","p"), c("3","4","5","kl","g","s","div","ab"),
c("k","ff","nb"), c("f","fk","n","int"),
c("k","fp"), c("sp","i","ab"),
c("5"), c("0","1","2","3","4","6","7","8","9"),
c("2"), c("1","0"),
c("2"), c("1","0"),
c("1"), c("2","0"),
c("1"), c("2","0"),
c("1"), c("2","0")
),2)
mapping_matrix = cbind(rules_a1, rules_a2, rules_b1, rules_b2)
rownames(mapping_matrix) = c("1","0")
# vector that can be read as a function mapping the indexes of its entries to other indexes
# used to map all 48 coded columns to only 42 columns with 0 and 1
index_mapper = c(
1,2,3,4,5,5,6,7,8,9,10,10,11,12,13,14,14,15,15,16,17,18,19,20,21,22,23,24,25,26,26,27,28,29,30,31,32,33,34,35,35,36,37,38,39,40,41,42
)
# Transform all data by iterating over input data row-wise
for (i in 1:nrow(data)) {
for (j in 1:ncol(data)) {
# skip columns where multiple conditions must be met
if (j %in% c(5,6,12,16,17,18,19,30,31,40,41)){
next
}
# TODO: Seperate multiple comma seperated entries
# check whether entry evaluates to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j])) {
if (check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# check whether entry evaluates to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j])) {
else if (check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep original coded value if it cannot be mapped to 1 or 0
else {
df[i,index_mapper[j]] = data[i,j]
}
}
}
# Transform data were multiple conditions must be met
# TODO: was wenn es nicht drin ist und nur eins von beidem nicht drin ist? dann wird check value false beim check ob es in 0 ist
for (i in 1:nrow(data)) {
for (j in c(5, 16, 18, 30, 40)) {
# both conditions must be met to be evaluated to 1
#if(data[i,j] %in% unlist(mapping_matrix["1",j]) && data[i,j+1] %in% unlist(mapping_matrix["1",j+1])) {
if(check_value(data[i,j],unlist(mapping_matrix["1",j]),FALSE) && check_value(data[i,j+1],unlist(mapping_matrix["1",j+1]),FALSE)) {
df[i,index_mapper[j]] = 1
}
# only one condition must be violated to be evaluated to 0
#else if(data[i,j] %in% unlist(mapping_matrix["0",j]) || data[i,j+1] %in% unlist(mapping_matrix["0",j+1])) {
else if(check_value(data[i,j],unlist(mapping_matrix["0",j]),TRUE) || check_value(data[i,j+1],unlist(mapping_matrix["0",j+1]),TRUE)) {
df[i,index_mapper[j]] = 0
}
# keep merged original coded value if it cannot be mapped to 1 or 0
else {
if (data[i,j] == "na" && data[i,j+1] =="na") {
df[i,index_mapper[j]] = "na"
} else {
df[i,index_mapper[j]] = paste(data[i,j],data[i,j+1])
}
}
}
}
View(df)
library(readr)
# Set working directory to folder where all R code related to the study is stored
# Note: this path must be changed if the code is used on a different computer
setwd("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R")
# Load helper functions
source("transformation_0_1/transform_codes_to_0_1.R")
# Read coded data of the three raters for classes TODO 17 - 20 (for now 19-20)
marc_raw <- read_csv2("irr/input_data/marc_19_20.csv", show_col_types = FALSE)
# Apply transformation rules to coded data
marc = transform_codes(data.frame(marc_raw, row.names = 1))
View(marc)
felix_raw <- read_csv2("irr/input_data/felix_19_20.csv", show_col_types = FALSE)
felix = transform_codes(data.frame(felix_raw, row.names = 1))
View(felix)
sina_raw <- read_csv2("irr/input_data/sina_19_20.csv", show_col_types = FALSE)
sina = transform_codes(data.frame(sina_raw, row.names = 1))
View(sina)
library(irr)
typeof(marc)
# Transformed data must be in the form of a matrix with dim (n*m) rows and one column
# with n = number of participants and m = number of tasks
flattened_list <- do.call(c, marc)
View(flattened_list)
# Transformed data must be in the form of a matrix with dim (n*m) rows and one column
# with n = number of participants and m = number of tasks
marc_col = list()
for (j in 1:ncol(marc)) {
append(marc_col,marc[,j])
}
View(marc_col)
marc[,1]
a=c(1,2,3)
b=c(4,5,6)
append(a,b)
a
# Transformed data must be in the form of a matrix with dim (n*m) rows and one column
# with n = number of participants and m = number of tasks
marc_col = matrix()
for (j in 1:ncol(marc)) {
marc_col = append(marc_col,marc[,j])
}
marc_col
t(marc_col)
View(marc_col)
typeof(marc_col)
marc_col
# Transformed data must be in the form of a matrix with dim (n*m) rows and one column
# with n = number of participants and m = number of tasks
marc_row = marc[1,]
for (i in 2:nrow(marc)) {
marc_row = append(marc_row,marc[i,])
}
marc_row
typeof(marc_row)
dim(marc_row)
nrow(marc_row)
c(marc_row,marc_row)
list(c(marc_row,marc_row),2)
marc[4,5]
type_of(marc[4,5])
typeof(marc[4,5])
test=array()
test
typeof(test)
marc_col = vector()
for (i in 1:nrow(marc)) {
for (j in 1:ncol(marc)) {
marc_col = append(marc_col,marc[i,j])
}
}
typeof(marc_col)
marc_col
nrow(marc_col)
a=vector()
a
a=c(1,2,3)
typeof(a)
felix_col = vector()
for (i in 1:nrow(felix)) {
for (j in 1:ncol(felix)) {
felix_col = append(felix_col,felix[i,j])
}
}
test = cbind(marc_col, felix_col)
test
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
sina_col = vector()
test = cbind(marc_col, sina_col)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
test = cbind(felix_col, sina_col)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
test = cbind(felix_col, marc_col)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
dim(marc)
dim(sina)
dim(felx)
dim(felix)
42*42
42*43
View(Sina)
View(sina)
View(Sina)
View(sina)
# TODO: Why are there two real NA values in table sina?
sina[19,32] = "na"
sina[43,32] = "na"
sina_col = vector()
for (i in 1:nrow(sina)) {
for (j in 1:ncol(sina)) {
sina_col = append(sina_col,sina[i,j])
}
}
test = cbind(sina_col, marc_col)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
test = cbind(sina_col, felix_col)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(test)
kappam.fleiss(cbind(marc_col,felix_col,sina_col))
library(readr)
library(irr)
# Set working directory to folder where all R code related to the study is stored
# Note: this path must be changed if the code is used on a different computer
setwd("C:/Users/Sina-/Dropbox/Lehrstuhl/Diss/Auswertung/R")
# Load helper functions
source("transformation_0_1/transform_codes_to_0_1.R")
# Read coded data of the three raters for classes 17-20
marc_raw <- read_csv2("irr/input_data/marc_17_20.csv", show_col_types = FALSE)
felix_raw <- read_csv2("irr/input_data/felix_17_20.csv", show_col_types = FALSE)
#sina_raw <- read_csv2("irr/input_data/sina_19_20.csv", show_col_types = FALSE)
# Apply transformation rules to coded data
marc = transform_codes(data.frame(marc_raw, row.names = 1))
felix = transform_codes(data.frame(felix_raw, row.names = 1))
#sina = transform_codes(data.frame(sina_raw, row.names = 1))
# TODO: Why are there two real NA values in table sina?
sina[19,32] = "na"
sina[43,32] = "na"
# Transformed data must be in the form of a matrix with dim (n*m) rows and one column
# with n = number of participants and m = number of tasks
marc_col = vector()
for (i in 1:nrow(marc)) {
for (j in 1:ncol(marc)) {
marc_col = append(marc_col,marc[i,j])
}
}
felix_col = vector()
for (i in 1:nrow(felix)) {
for (j in 1:ncol(felix)) {
felix_col = append(felix_col,felix[i,j])
}
}
#sina_col = vector()
#for (i in 1:nrow(sina)) {
#  for (j in 1:ncol(sina)) {
#    sina_col = append(sina_col,sina[i,j])
#  }
#}
#View(sina)
# Determine inter-rater reliability using Cohen's Kappa
kappa2(cbind(marc_col,felix_col))
#kappam.fleiss(cbind(marc_col,felix_col,sina_col))
# TODO: remove this line for IRR of 0/1, this is just a test for the IRR for all categories
marc = data.frame(marc_raw, row.names = 1)
felix = data.frame(felix_raw, row.names = 1)
marc_col = vector()
for (i in 1:nrow(marc)) {
for (j in 1:ncol(marc)) {
marc_col = append(marc_col,marc[i,j])
}
}
felix_col = vector()
for (i in 1:nrow(felix)) {
for (j in 1:ncol(felix)) {
felix_col = append(felix_col,felix[i,j])
}
}
# Determine inter-rater reliability using Cohen's Kappa
kappa2(cbind(marc_col,felix_col))
# Read coded data of the three raters for classes 17-20
marc_raw <- read_csv2("irr/input_data/marc_17_20.csv", show_col_types = FALSE)
felix_raw <- read_csv2("irr/input_data/felix_17_20.csv", show_col_types = FALSE)
# TODO: remove this line for IRR of 0/1, this is just a test for the IRR for all categories
marc = data.frame(marc_raw, row.names = 1)
felix = data.frame(felix_raw, row.names = 1)
marc_col = vector()
for (i in 1:nrow(marc)) {
for (j in 1:ncol(marc)) {
marc_col = append(marc_col,marc[i,j])
}
}
felix_col = vector()
for (i in 1:nrow(felix)) {
for (j in 1:ncol(felix)) {
felix_col = append(felix_col,felix[i,j])
}
}
# Determine inter-rater reliability using Cohen's Kappa
kappa2(cbind(marc_col,felix_col))
View(marc_col)
marc_col
agree(cbind(marc_col,felix_col))
# TODO: remove this line for IRR of 0/1, this is just a test for the IRR for all categories
# everything is for the IRR of the original codes
marc = data.frame(marc_raw, row.names = 1)
felix = data.frame(felix_raw, row.names = 1)
for (j in 1:ncol(marc)) {
kappa2(cbind(marc[,j],felix[,j]))
}
for (j in 1:ncol(marc)) {
kappa2(cbind(marc[,j],felix[,j]))
}
kappa2(cbind(marc[,1],felix[,1]))
View(marc)
kappa2(cbind(marc[,4],felix[,4]))
kappa2(cbind(marc[,6],felix[,6]))
kappa2(cbind(marc[,16],felix[,16]))
